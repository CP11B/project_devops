# QAC SFIA2 Project - Cara Prestwich and Emily Nixon

This application is a simple [Flask application](https://flask.palletsprojects.com/en/1.1.x/quickstart/#a-minimal-application), that we had to deploy as our SFIA2 project. 

The brief for the project can be found at the end of this README. 

The following information covers everything you need to start it up.

## Prerequisites

- Terraform must be installed on your local machine
- You'll need to have a VM with ansible installed on it (As future improvements we could make to this project, intergrating this VM into Terraform would be one thing we could do)

## Terraform Environment Variables

Before you start using Terraform, there are a few variables that need to be set. These have been set locally in SystemPropertiesAdvanced. 

To set the variables, use Windows Key + R, to bring up Run, and type in "SystemPropertiesAdvanced". From here, you want to click "Environment Variables" at the bottom of the
pop-up. Next, in the box at the bottom, "System Variables", you want to click New, and then enter "TF_VAR_access_key" into the "Variable Name" box, and then enter your AWS 
Access Key into the "Variable Value" box. You will need to do the same with "TF_VAR_secret_key" and "TF_VAR_db_password". The DB password is what will be set as the 
MySQL Database Password on AWS when you run Terraform apply, so you can set this to be whatever you want it to be. 

## Terraform 

Once you've cloned down the application, and set the environment variables, cd into the Terraform folder, and perform the following commands.

- Terraform init

This initialises Terraform

- Terraform plan

This prints out all the changes that will be made if you run terraform apply

- Terraform Apply

this applies those changes, and builds the Terraform infrastructure. Remember to type "yes" when prompted. 

When you're done with everything, you can perform "Terraform Destroy" to tear down all your Terraform infrastructure. 

## SSH-ing and Ansible

To run the Ansible playbook we need to share a key pair between our ansible machines and the VMs we created with Terraform. In the ansible machine I created a new key pair
called ansible_id_rsa using the command "ssh-keygen" - leaving the passphrase empty. After this, you want to copy the public key thats been generated by this keypair, and
paste it into the "authorized-keys" file in the .ssh folders of the VMs created. (The IPs of these VMs can be found in a file in the terraform root directory thats generated
when you build the terraform infrastructure). 

After this, you want to clone the repository down onto your ansible machine, and update the inventory.yaml file, and change the IPs to the IPs of the VMs created. 

Then, all you need to do to run the playbook is run the command "ansible-playbook -i inventory.yaml playbook.yaml". 

## Setting up the Database

We also need to make sure the database instance has initialised properly, as we were having issues with our create.sql file not working. To do this we SSH onto a VM thats in
the VPC, I did this on the Jenkins VM. Then, we have to make sure SQL is installed on the VM, we can install it with "sudo apt install mysql-client-core-8.0"
From here we have to connect to the mysql database by running "mysql -h <ENTER YOUR DB END POINT HERE> -u admin -p <ENTER DB PASSWORD HERE>"

The DB ENDPOINT can be found on your AWS account, under the RDS, in the Connectivity & Security tab. 

After this, you want to run the following commands (these are all found in the create.sql) -

CREATE DATABASE testdb;
CREATE DATABASE users;
USE users;

DROP TABLE IF EXISTS `users`;

CREATE TABLE `users` (
  `userName` varchar(30) NOT NULL
);

INSERT INTO `users` VALUES ('Bob'),('Jay'),('Matt'),('Ferg'),('Mo');

after this, your DB should be set up and ready to go!

## Setting up Jenkins

When we ran the ansible playbook earlier, it should spit out the initial admin password for Jenkins. Make a note of this, and then navigate to port 80 of the IP of your
Jenkins VM. Then, add in the initial admin password when prompted, create an admin user, and select suggested plugins. Once they've all installed and good to go, you're
ready to add in credentials. Go to Manage Jenkins, then Manage Credentials. When you hover over "Global" under "domains", there should be a little arrow you can press, and then click add credentials.

Under kind, select secret text, keep the scope as it is, and then enter the following. 

First - in secret enter your dockerhub username, then in ID label it as DOCKER_USERNAME, you can keep this same description for description. Then click ok. You'll need to do this for DOCKER_PASSWORD (using the password for your dockerhub), and MYSQL_ROOT_PASSWORD (using the password we set for SQL in our environment variables, your DB password). 

Once you've done this, we can create the Pipeline project! Navigate back to your dashboard, and click "new item", enter a name for your pipeline, and select "Pipeline" from the types of project on the page, then click ok.

Now, on the configuration page, you can select "github project" from the first set of tick boxes, and enter your project url.

Under build triggers, we want to select "GitHub hook trigger for GIRScm polling" 

Under pipeline, select "Pipeline script from SCM" from the dropdown menu, then git under "SCM", and then enter your Repo URL. 
We also want to specify the branch here, we've got 2 pipeline projects, one for listening to changes on "Main" and one for listening
to changes on "Dev". Otherwise, we want to make sure that Jenkinsfile is selected as the script path, but then we can click "Save" and out project is nearly ready to go! 

Lastly, navigate to your git repo, and under settings select "Webhooks" and then "add webhook". In payload url, enter "http://<YOUR-JENKINS_IP>:8080/github-webhook/", then
select application/json as content type, and "Just the push event" under "Which events would you like to trigger this webhook?"

After this, we are all set to go! 

# Brief

The application must:

- Be deployed to a **Virtual Machine for testing**
- Be deployed in a **Docker Stack Using compose**
- Make use of a **managed Database solution**

## Application

The application is a Flask application running in **2 micro-services** (*frontend* and *backend*).  

The database directory is available should you: 
  - want to use a MySQL container for your database at any point, *or*
  - want to make use of the `Create.sql` file to **set up and pre-populate your database**.

The application works by:
1. The frontend service making a GET request to the backend service. 
2. The backend service using a database connection to query the database and return a result.
3. The frontend service serving up a simple HTML (`index.html`) to display the result.

### Database Connection

The database connection is handled in the `./backend/application/__init__.py` file.

A typical Database URI follows the form:

```
mysql+pymysql://[db-user]:[db-password]@[db-host]/[db-name]
```

An example of this would be:

```
mysql+pymysql://root:password@mysql:3306/orders
```

### Environment Variables

The application makes use of **2 environment variables**:

- `DATABASE_URI`: as described above
- `SECRET_KEY`: any *random string* will work here

### Running a Flask Application

Typically, to run a Flask application, you would:

1. Install the pip dependencies:

```
pip install -r requirements.txt
```

2. Run the application:

```
python3 app.py
```

![app-diagram](https://i.imgur.com/wnbDazy.png)

## Testing

Unit Tests have been included for both the frontend and backend services.

To test the backend service, you will need two things:

1. A database called `testdb`
2. A `TEST_DATABASE_URI` environment variable, which contains the database connection for the `testdb` database.

You can run the tests using the command:

```
pytest
```

To generate a coverage report, you will need to run:

```
pytest --cov application
```

## Infrastructure

The **Minimum Viable Product** for this project should at least demonstrate the following infrastructure diagram:

![mvp-diagram](https://i.imgur.com/i5qfOas.png)

**Stretch goals** for this project include:

- Using **Terraform to configure the Production VM**
- Using **Terraform and Ansible to configure the Test VM**

Completing the stretch goals should yield an infrastructure diagram similar to the following:

![stretch-digram](https://i.imgur.com/Q5zljVl.png)

**Good luck!**
