# QAC SFIA2 Project - Cara Prestwich and Emily Nixon

This application is a simple [Flask application](https://flask.palletsprojects.com/en/1.1.x/quickstart/#a-minimal-application), that we had to deploy as our SFIA2 project. 

The brief for the project can be found at the end of this README. 

The following information covers everything you need to start it up.

We planned the project using Jira, the board can be found [here](https://team-1612863386042.atlassian.net/secure/RapidBoard.jspa?projectKey=DEV&rapidView=4)

## Prerequisites

- Terraform must be installed on your local machine
- An Ansible-Controller VM (a machine with Ansible installed onto it.)
- An AWS account
- A dockerhub account
- A GitHub account

## Terraform Environment Variables

Before using Terraform, there are a few variables that need to be set. These are set locally in SystemPropertiesAdvanced. 

### To set the variables on a local Windows machine

1. Press the Windows Key.

2. Type in `env`.

3. Click *"Edit the system environment variables"* at the bottom of the pop-up. 

4. Click the box at the bottom *"Environment Variables"* to bring up a new window. 

5. Click New under *"System Variables"* and then enter `TF_VAR_access_key` into the *"Variable name"* box, and enter your AWS Access Key into the *"Variable Value"* box. Click "OK" to save.

6. Repeat step 5 with `TF_VAR_secret_key` and `TF_VAR_db_password`. **The DB password is what will be set as the MySQL Database Password on AWS when you run Terraform later on, so you can set this to be whatever you want it to be (min of 8 chars).**

## Terraform 

1. In a terminal `git clone https://github.com/CP11B/project_devops`

*You will need to change the ssh_key_name(line 40 of terraform/main.tf) to one you already have. It is suggested that you use aws-cli to run `aws ec2 create-key-pair --key-name [KEY_PAIR_NAME]`*

2. Navigate to the Terraform folder and perform the following commands.

3. `terraform init` This initialises Terraform.

4. `terraform plan` This prints out all the changes that will be made if you run terraform apply.

5. `terraform apply` This applies those changes, and builds the Terraform infrastructure. Remember to type "yes" when prompted. 

When you're done with everything, you can perform `terraform destroy` from this folder to tear down all your Terraform infrastructure. 

*The IPs of these VMs can be found in a new file called *tf_ips* in the terraform directory*

## SSH-ing and Ansible

To run the Ansible playbook we need to share a key pair between our Ansible-Controller and the VMs we created with Terraform. 

1. In the Ansible-Controller, create a new key pair using the command `ssh-keygen` called **ansible_id_rsa**. Leave the passphrase *empty*. 

2. Copy the public key thats been generated by this keypair.

3. SSH onto one of the newly created machines and navigate to the .ssh directory. 

4. Paste the public key into the "authorized-keys" file. 

5. Repeat for all newly-created machines (jenkins, prod, test)

6. Clone the repository down onto your Ansible-Controller using `git clone https://github.com/CP11B/project_devops`

7. Change lines 5, 8 and 11 to the public IPs of the newly created machines. 

8. Run the Ansible playbook with the command `ansible-playbook -i inventory.yaml playbook.yaml` 
*Make note of the **Init Password Jenkins** that will appear, you will need this later*

## Setting up the Database

We also need to make sure the database instance has initialised properly, as we were having issues with our create.sql file not working. 

1. Go to your AWS console, and look under RDS in the Connectivity & Security tab. Make a note of the endpoint. 

2. Using one of the machines in the VPC (jenkins, prod or test), install SQL with `sudo apt install mysql-client-core-8.0`

3. Connect to the mysql database by with `mysql -h <DB END POINT> -u admin -p` and enter your password when prompted (this is the password you set earlier on in the Terraform- it will be in your Windows Env Variables if you can't remember it.)

4. Run the following commands (these are all found in the create.sql)

`CREATE DATABASE testdb;
CREATE DATABASE users;
USE users;
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `userName` varchar(30) NOT NULL
);
INSERT INTO `users` VALUES ('Bob'),('Jay'),('Matt'),('Ferg'),('Mo');
`

After this, your DB should be set up and ready to go! `Ctrl + D to get out of mysql` if you want to.

## Setting up Jenkins

1. Navigate to port 8080 of the IP of your Jenkins VM IP in your browser. Then, add in the **initial admin password** when prompted (which we were given earlier from Ansible), create an admin user, and select suggested plugins. 

2. Go to *Manage Jenkins*, then *Manage Credentials*. When you hover over *(global)* under *Domains*, click on the little arrow, and then click *add credentials*.

3. Select *Secret text* from the top dropdown menu, keeping the scope as it is, and then enter the following. 

- In *secret* enter your own *dockerhub username*, then under *ID* write `DOCKER_USERNAME`, you can keep this same description for description. Click ok. 

4. Repeat this for `DOCKER_PASSWORD` (using the password for your dockerhub), and `MYSQL_ROOT_PASSWORD` (using the password we set for SQL in our environment variables, your DB password). 

Once you've done this, we can create the Pipeline project! 

5. Navigate back to your dashboard, and click *"New Item"*, name your pipeline, and select *"Pipeline"* from the types of project on the page, then click OK.

6. On the configuration page: 
- Select *"Github project"* from the first set of tick boxes, and enter your project url underneath. 
- Under the *Build Triggers* section, select *"GitHub hook trigger for GITScm polling"* 
- Under the *Pipeline* section, select *"Pipeline script from SCM"* from the dropdown menu, from the "SCM" dropdown select *Git*, and then enter your Repo URL. We also want to specify the branch here, we've got 2 pipeline projects, one for listening to changes on *"Main"* and one for listening
to changes on *"Dev"*. Make sure that Jenkinsfile is selected as the script path, then click "Save". 

7. Navigate to your Github repository, and under settings select *"Webhooks"* and then *"Add webhook"*. In payload url, enter `http://<YOUR-JENKINS_IP>:8080/github-webhook/`. Select *application/json* under the *Content type* dropdown and leave the rest as default. Add the webook.

After this, we are all set to go! 

## Future Improvements
1. Integration of the Ansible-Controller VM into Terraform
2. Automation of the private IP placement onto the inventory.yaml
3. Automate keygen and place the keys onto the authorized_keys file

## Debugging
### Terraform
- Check your AWS creds are correct and on the correct path.
- Check that you are pointing to the correct ssh key name.

### Ansible
- Check that you are using the correct IP adresses in the inventory.yaml
- Check that the ansible_id_rsa key is present in the authorized_key file

### Jenkins
- Unfortunately, if you have changed the Jenkins password whilst logging in and you've lost it you'll need to start the process over from `terraform apply`
- If your webhook isn't triggering a Jenkins build, be patient for a few manual builds- it's a known issue when it may not detect the first couple of builds


## Brief

The application must:

- Be deployed to a **Virtual Machine for testing**
- Be deployed in a **Docker Stack Using compose**
- Make use of a **managed Database solution**

## Application

The application is a Flask application running in **2 micro-services** (*frontend* and *backend*).  

The database directory is available should you: 
  - want to use a MySQL container for your database at any point, *or*
  - want to make use of the `Create.sql` file to **set up and pre-populate your database**.

The application works by:
1. The frontend service making a GET request to the backend service. 
2. The backend service using a database connection to query the database and return a result.
3. The frontend service serving up a simple HTML (`index.html`) to display the result.

### Database Connection

The database connection is handled in the `./backend/application/__init__.py` file.

A typical Database URI follows the form:

```
mysql+pymysql://[db-user]:[db-password]@[db-host]/[db-name]
```

An example of this would be:

```
mysql+pymysql://root:password@mysql:3306/orders
```

### Environment Variables

The application makes use of **2 environment variables**:

- `DATABASE_URI`: as described above
- `SECRET_KEY`: any *random string* will work here

### Running a Flask Application

Typically, to run a Flask application, you would:

1. Install the pip dependencies:

```
pip install -r requirements.txt
```

2. Run the application:

```
python3 app.py
```

![app-diagram](https://i.imgur.com/wnbDazy.png)

## Testing

Unit Tests have been included for both the frontend and backend services.

To test the backend service, you will need two things:

1. A database called `testdb`
2. A `TEST_DATABASE_URI` environment variable, which contains the database connection for the `testdb` database.

You can run the tests using the command:

```
pytest
```

To generate a coverage report, you will need to run:

```
pytest --cov application
```

## Infrastructure

The **Minimum Viable Product** for this project should at least demonstrate the following infrastructure diagram:

![mvp-diagram](https://i.imgur.com/i5qfOas.png)

**Stretch goals** for this project include:

- Using **Terraform to configure the Production VM**
- Using **Terraform and Ansible to configure the Test VM**

Completing the stretch goals should yield an infrastructure diagram similar to the following:

![stretch-digram](https://i.imgur.com/Q5zljVl.png)

**Good luck!**
