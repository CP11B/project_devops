# QAC SFIA2 Project - Cara Prestwich and Emily Nixon

This application is a simple [Flask application](https://flask.palletsprojects.com/en/1.1.x/quickstart/#a-minimal-application), that we had to deploy as our SFIA2 project. 

The brief for the project can be found at the end of this README. 

The following information covers everything you need to start it up.

## Prerequisites

- Terraform must be installed on your local machine
- An Ansible-Controller VM (a machine with Ansible installed onto it.)
- An AWS account

## Terraform Environment Variables

Before using Terraform, there are a few variables that need to be set. These are set locally in SystemPropertiesAdvanced. 

### To set the variables on a local Windows machine

1. Press the Windows Key.

2. Type in `env`.

3. Click *"Edit the system environment variables"* at the bottom of the pop-up. 

4. Click the box at the bottom *"Environment Variables"* to bring up a new window. 

5. Click New under *"System Variables"* and then enter `TF_VAR_access_key` into the *"Variable name"* box, and enter your AWS Access Key into the *"Variable Value"* box. Click "OK" to save.

6. Repeat step 5 with `TF_VAR_secret_key` and `TF_VAR_db_password`. *The DB password is what will be set as the MySQL Database Password on AWS when you run Terraform later on, so you can set this to be whatever you want it to be (min of 8 chars).*

## Terraform 

1. In a terminal `git clone https://github.com/CP11B/project_devops`

*You will need to change the ssh_key_name(line 40 of terraform/main.tf) to one you already have. It is suggested that you use aws-cli to run run `aws ec2 create-key-pair --key-name [KEY_PAIR_NAME]`*

2. Navigate to the Terraform folder and perform the following commands.

3. `terraform init` This initialises Terraform.

4. `terraform plan` This prints out all the changes that will be made if you run terraform apply.

5. `terraform apply` This applies those changes, and builds the Terraform infrastructure. Remember to type "yes" when prompted. 

When you're done with everything, you can perform `terraform destroy` from this folder to tear down all your Terraform infrastructure. 

*The IPs of these VMs can be found in a new file called *tf_ips* in the terraform directory*

## SSH-ing and Ansible

To run the Ansible playbook we need to share a key pair between our Ansible-Controller and the VMs we created with Terraform. 

1. In the Ansible-Controller, create a new key pair using the command `ssh-keygen` called **ansible_id_rsa**. Leave the passphrase *empty*. 

2. Copy the public key thats been generated by this keypair.

3. SSH onto one of the newly created machines and navigate to the .ssh directory. 

4. Paste the public key into the "authorized-keys" file. 

5. Repeat for all newly-created machines (jenkins, prod, test)

6. Clone the repository down onto your Ansible-Controller using `git clone https://github.com/CP11B/project_devops`

7. Change lines 5, 8 and 11 to the private IPs of the newly created machines. *These can be found on the AWS console, or by running the AWS-CLI command `aws ec2 describe-instances --filters "Name=instance-state-name,Values=running" --query 'Reservations[*].Instances[*].[PrivateIpAddress, PublicIpAddress]'`*

8. Run the Ansible playbook with the command `ansible-playbook -i inventory.yaml playbook.yaml` 

## Setting up the Database

We also need to make sure the database instance has initialised properly, as we were having issues with our create.sql file not working. To do this we SSH onto a VM thats in the VPC, I did this on the Jenkins VM. Then, we have to make sure SQL is installed on the VM, we can install it with "sudo apt install mysql-client-core-8.0"
From here we have to connect to the mysql database by running "mysql -h <ENTER YOUR DB END POINT HERE> -u admin -p <ENTER DB PASSWORD HERE>"

The DB ENDPOINT can be found on your AWS account, under the RDS, in the Connectivity & Security tab. 

After this, you want to run the following commands (these are all found in the create.sql) -

CREATE DATABASE testdb;
CREATE DATABASE users;
USE users;

DROP TABLE IF EXISTS `users`;

CREATE TABLE `users` (
  `userName` varchar(30) NOT NULL
);

INSERT INTO `users` VALUES ('Bob'),('Jay'),('Matt'),('Ferg'),('Mo');

after this, your DB should be set up and ready to go!

## Setting up Jenkins

When we ran the ansible playbook earlier, it should spit out the initial admin password for Jenkins. Make a note of this, and then navigate to port 80 of the IP of your
Jenkins VM. Then, add in the initial admin password when prompted, create an admin user, and select suggested plugins. Once they've all installed and good to go, you're
ready to add in credentials. Go to Manage Jenkins, then Manage Credentials. When you hover over "Global" under "domains", there should be a little arrow you can press, and then click add credentials.

Under kind, select secret text, keep the scope as it is, and then enter the following. 

First - in secret enter your dockerhub username, then in ID label it as DOCKER_USERNAME, you can keep this same description for description. Then click ok. You'll need to do this for DOCKER_PASSWORD (using the password for your dockerhub), and MYSQL_ROOT_PASSWORD (using the password we set for SQL in our environment variables, your DB password). 

Once you've done this, we can create the Pipeline project! Navigate back to your dashboard, and click "new item", enter a name for your pipeline, and select "Pipeline" from the types of project on the page, then click ok.

Now, on the configuration page, you can select "github project" from the first set of tick boxes, and enter your project url.

Under build triggers, we want to select "GitHub hook trigger for GIRScm polling" 

Under pipeline, select "Pipeline script from SCM" from the dropdown menu, then git under "SCM", and then enter your Repo URL. 
We also want to specify the branch here, we've got 2 pipeline projects, one for listening to changes on "Main" and one for listening
to changes on "Dev". Otherwise, we want to make sure that Jenkinsfile is selected as the script path, but then we can click "Save" and out project is nearly ready to go! 

Lastly, navigate to your git repo, and under settings select "Webhooks" and then "add webhook". In payload url, enter "http://<YOUR-JENKINS_IP>:8080/github-webhook/", then
select application/json as content type, and "Just the push event" under "Which events would you like to trigger this webhook?"

After this, we are all set to go! 

## Future Improvements
1. Integration of the Ansible-Controller VM into Terraform
2. Automation of the private IP placement onto the inventory.yaml
3. Automate keygen and place the keys onto the authorized_keys file


## Brief

The application must:

- Be deployed to a **Virtual Machine for testing**
- Be deployed in a **Docker Stack Using compose**
- Make use of a **managed Database solution**

## Application

The application is a Flask application running in **2 micro-services** (*frontend* and *backend*).  

The database directory is available should you: 
  - want to use a MySQL container for your database at any point, *or*
  - want to make use of the `Create.sql` file to **set up and pre-populate your database**.

The application works by:
1. The frontend service making a GET request to the backend service. 
2. The backend service using a database connection to query the database and return a result.
3. The frontend service serving up a simple HTML (`index.html`) to display the result.

### Database Connection

The database connection is handled in the `./backend/application/__init__.py` file.

A typical Database URI follows the form:

```
mysql+pymysql://[db-user]:[db-password]@[db-host]/[db-name]
```

An example of this would be:

```
mysql+pymysql://root:password@mysql:3306/orders
```

### Environment Variables

The application makes use of **2 environment variables**:

- `DATABASE_URI`: as described above
- `SECRET_KEY`: any *random string* will work here

### Running a Flask Application

Typically, to run a Flask application, you would:

1. Install the pip dependencies:

```
pip install -r requirements.txt
```

2. Run the application:

```
python3 app.py
```

![app-diagram](https://i.imgur.com/wnbDazy.png)

## Testing

Unit Tests have been included for both the frontend and backend services.

To test the backend service, you will need two things:

1. A database called `testdb`
2. A `TEST_DATABASE_URI` environment variable, which contains the database connection for the `testdb` database.

You can run the tests using the command:

```
pytest
```

To generate a coverage report, you will need to run:

```
pytest --cov application
```

## Infrastructure

The **Minimum Viable Product** for this project should at least demonstrate the following infrastructure diagram:

![mvp-diagram](https://i.imgur.com/i5qfOas.png)

**Stretch goals** for this project include:

- Using **Terraform to configure the Production VM**
- Using **Terraform and Ansible to configure the Test VM**

Completing the stretch goals should yield an infrastructure diagram similar to the following:

![stretch-digram](https://i.imgur.com/Q5zljVl.png)

**Good luck!**
